<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualizer Pro Ultimate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Lobster&family=Poppins:wght@400;600;700&family=Roboto+Mono&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0;
            overflow-x: hidden;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        .control-panel {
            background-color: #1e293b;
            border-top: 1px solid #334155;
        }

        .preview-container {
            background: #000;
            background-image: radial-gradient(circle at center, #1a1a1a 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Custom Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #6366f1; /* Indigo 500 */
            margin-top: -5px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #818cf8;
        }

        /* Checkbox Toggle */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #6366f1;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #6366f1;
        }

        .preset-btn {
            background-color: #334155;
            border: 1px solid #475569;
            width: 2rem;
            height: 2rem;
            border-radius: 0.375rem;
            transition: all 0.2s;
        }
        .preset-btn:hover {
            background-color: #6366f1;
            border-color: #818cf8;
        }
        .preset-btn.active {
            background-color: #4f46e5;
            border-color: #818cf8;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.5);
        }

        /* Loader */
        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-left-color: #6366f1;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- Main Layout -->
    <div class="flex flex-col h-full md:flex-row">
        
        <!-- LEFT/TOP: Preview Area -->
        <div id="previewPanel" class="w-full md:w-2/3 h-[50vh] md:h-full relative flex items-center justify-center preview-container overflow-hidden">
            <div class="relative shadow-2xl shadow-black/50 rounded-lg overflow-hidden" style="aspect-ratio: 16/9; max-height: 95%; max-width: 95%;">
                <canvas id="visualizerCanvas" width="1280" height="720" class="w-full h-full object-contain block bg-black"></canvas>
            </div>
            
            <!-- Hidden Media Elements -->
            <audio id="audioElement" crossOrigin="anonymous"></audio>
            <video id="videoElement" crossOrigin="anonymous" loop playsinline muted class="hidden"></video>
            
            <!-- Overlay Status -->
            <div id="overlayStatus" class="absolute top-4 left-4 bg-black/70 backdrop-blur-sm px-4 py-2 rounded-full text-xs font-mono text-indigo-300 hidden border border-indigo-500/30">
                <span class="loader"></span> Processing...
            </div>
        </div>

        <!-- RIGHT/BOTTOM: Controls -->
        <div class="w-full md:w-1/3 h-[50vh] md:h-full control-panel flex flex-col overflow-hidden z-10 shadow-xl">
            
            <!-- Header -->
            <div class="p-4 bg-slate-800 border-b border-slate-700 flex justify-between items-center shrink-0">
                <h1 class="text-xl font-bold bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent">
                    Audio Visualizer Pro
                </h1>
                <div class="flex gap-2">
                    <button id="previewBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-1.5 rounded-md text-sm font-semibold shadow-lg shadow-indigo-500/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        Play
                    </button>
                </div>
            </div>

            <!-- Scrollable Settings -->
            <div class="flex-1 overflow-y-auto p-5 space-y-6">
                
                <!-- Section 1: Media -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider border-b border-slate-700 pb-1">Media Sources</h2>
                    
                    <div class="grid grid-cols-1 gap-3">
                        <div class="group">
                            <label class="block text-xs text-slate-400 mb-1 group-hover:text-indigo-400 transition-colors">Background (Image/Video)</label>
                            <input type="file" id="bgInput" accept="image/*,video/*" class="block w-full text-xs text-slate-300 file:mr-3 file:py-1.5 file:px-3 file:rounded-md file:border-0 file:text-xs file:font-semibold file:bg-slate-700 file:text-indigo-300 hover:file:bg-slate-600 cursor-pointer bg-slate-800 rounded-md border border-slate-700">
                        </div>
                        <div class="group">
                            <label class="block text-xs text-slate-400 mb-1 group-hover:text-indigo-400 transition-colors">Audio File</label>
                            <input type="file" id="audioInput" accept="audio/*" class="block w-full text-xs text-slate-300 file:mr-3 file:py-1.5 file:px-3 file:rounded-md file:border-0 file:text-xs file:font-semibold file:bg-slate-700 file:text-indigo-300 hover:file:bg-slate-600 cursor-pointer bg-slate-800 rounded-md border border-slate-700">
                        </div>
                        <div class="group">
                            <label class="block text-xs text-slate-400 mb-1 group-hover:text-indigo-400 transition-colors">Logo Overlay (Optional)</label>
                            <input type="file" id="djLogoInput" accept="image/*" class="block w-full text-xs text-slate-300 file:mr-3 file:py-1.5 file:px-3 file:rounded-md file:border-0 file:text-xs file:font-semibold file:bg-slate-700 file:text-indigo-300 hover:file:bg-slate-600 cursor-pointer bg-slate-800 rounded-md border border-slate-700">
                        </div>
                    </div>
                </div>

                <!-- Section 2: Spectrum -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider border-b border-slate-700 pb-1">Spectrum Settings</h2>
                    
                    <div class="grid grid-cols-2 gap-3">
                        <div class="col-span-2">
                            <label class="block text-xs text-slate-400 mb-1">Visual Style</label>
                            <select id="spectrumType" class="w-full bg-slate-800 border border-slate-700 text-white text-sm rounded-md p-2 focus:ring-2 focus:ring-indigo-500 outline-none">
                                <option value="bars">Classic Bars</option>
                                <option value="digital-eq">Digital EQ (Retro)</option> <!-- New -->
                                <option value="classic-circle">Classic Round Bars</option>
                                <option value="eclipse">Eclipse Aura (New)</option> <!-- New -->
                                <option value="spiral-wave">Spiral Wave (New)</option> <!-- New -->
                                <option value="hexagon">Hexagon Pulse</option>
                                <option value="seismic">Seismic Wave</option>
                                <option value="bouncing-bars">Bouncing Bars</option>
                                <option value="circle-bars">Radial Bars</option>
                                <option value="dj-disc">Vinyl Disc</option>
                                <option value="ring-spectrum">Neon Ring</option>  
                                <option value="ncs-lines">NCS Wave</option>  
                                <option value="wave-mesh">Cyber Mesh</option>  
                                <option value="wireframe-3d">3D Tunnel</option>
                                <option value="frequency-mirror">Mirror Quad</option>
                                <option value="dual-lines">Dual Horizon</option>
                                <option value="wave">Oscilloscope</option>
                                <option value="none">Hidden</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Color Start</label>
                            <input type="color" id="spectrumColor1" value="#6366f1" class="w-full h-8 rounded cursor-pointer bg-transparent">
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Color End</label>
                            <input type="color" id="spectrumColor2" value="#ec4899" class="w-full h-8 rounded cursor-pointer bg-transparent">
                        </div>
                    </div>

                    <div id="barControls" class="grid grid-cols-2 gap-3 p-3 bg-slate-800/50 rounded-lg border border-slate-700/50">
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Bar Count</label>
                            <input id="spectrumNumBars" type="range" min="32" max="256" value="64" step="16" class="w-full">
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Thickness</label>
                            <input id="spectrumBarThickness" type="range" min="2" max="40" value="8" class="w-full">
                        </div>
                    </div>

                    <!-- New Positioning Controls -->
                     <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Scale X</label>
                            <input id="spectrumWidth" type="range" min="10" max="150" value="100" class="w-full">
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Scale Y</label>
                            <input id="spectrumHeight" type="range" min="10" max="150" value="50" class="w-full">
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Position X</label>
                            <input id="spectrumPosX" type="range" min="0" max="100" value="50" class="w-full">
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Position Y</label>
                            <input id="spectrumPosY" type="range" min="0" max="100" value="50" class="w-full">
                        </div>
                    </div>
                </div>

                <!-- Section 3: Effects -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider border-b border-slate-700 pb-1">FX & Particles</h2>
                    
                    <div class="flex justify-between items-center bg-slate-800 p-2 rounded-md border border-slate-700">
                        <span class="text-sm text-slate-300">Bloom (Glow)</span>
                        <div class="relative inline-block w-10 align-middle select-none">
                            <input type="checkbox" id="bloomEffect" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer transition-all duration-300"/>
                            <label for="bloomEffect" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer transition-all duration-300"></label>
                        </div>
                    </div>
                    <div id="bloomIntensityContainer" class="hidden px-2">
                        <label class="block text-xs text-slate-400 mb-1">Glow Intensity</label>
                        <input id="bloomIntensity" type="range" min="5" max="60" value="20" class="w-full">
                    </div>

                    <div class="flex justify-between items-center bg-slate-800 p-2 rounded-md border border-slate-700">
                        <span class="text-sm text-slate-300">Background Pulse</span>
                        <div class="relative inline-block w-10 align-middle select-none">
                            <input type="checkbox" id="bgPulseEffect" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer transition-all duration-300"/>
                            <label for="bgPulseEffect" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer transition-all duration-300"></label>
                        </div>
                    </div>

                    <div>
                        <label class="block text-xs text-slate-400 mb-1">Particle System</label>
                        <select id="particleType" class="w-full bg-slate-800 border border-slate-700 text-white text-sm rounded-md p-2 outline-none">
                            <option value="none">None</option>
                            <option value="particles">Floating Dust</option>
                            <option value="particle-rain">Digital Rain</option>
                            <option value="spinning-galaxy">Galaxy Spiral</option>
                        </select>
                    </div>
                    <div id="particleControls" class="hidden grid grid-cols-2 gap-3">
                        <select id="particleShape" class="bg-slate-800 border border-slate-700 text-white text-xs rounded-md p-1">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                            <option value="triangle">Triangle</option>
                        </select>
                        <input id="particleOpacity" type="range" min="0" max="100" value="60" class="w-full">
                    </div>
                </div>

                <!-- Section 4: Text -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider border-b border-slate-700 pb-1">Text Overlay</h2>
                    <div class="space-y-2">
                        <input type="text" id="textLine1" placeholder="Song Title / Main Text" class="w-full bg-slate-800 border border-slate-700 text-white text-sm rounded-md p-2">
                        <input type="text" id="textLine2" placeholder="Artist / Sub Text" class="w-full bg-slate-800 border border-slate-700 text-white text-sm rounded-md p-2">
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                         <select id="textFontFamily" class="bg-slate-800 border border-slate-700 text-white text-xs rounded-md p-2">
                            <option value="Poppins">Poppins (Modern)</option>
                            <option value="Bebas Neue">Bebas Neue (Tall)</option>
                            <option value="Lobster">Lobster (Cursive)</option>
                            <option value="Roboto Mono">Roboto Mono (Code)</option>
                        </select>
                        <input id="textFontSize" type="range" min="20" max="150" value="60" class="w-full">
                    </div>
                    
                     <!-- Text Positioning Grid -->
                    <div class="flex flex-col gap-2">
                        <label class="text-xs text-slate-400">Alignment Presets</label>
                        <div id="text-position-presets" class="grid grid-cols-3 gap-2 w-24 mx-auto">
                            <button data-pos="top-left" class="preset-btn"></button>
                            <button data-pos="top-center" class="preset-btn"></button>
                            <button data-pos="top-right" class="preset-btn"></button>
                            <button data-pos="middle-left" class="preset-btn"></button>
                            <button data-pos="middle-center" class="preset-btn"></button>
                            <button data-pos="middle-right" class="preset-btn"></button>
                            <button data-pos="bottom-left" class="preset-btn"></button>
                            <button data-pos="bottom-center" class="preset-btn active"></button>
                            <button data-pos="bottom-right" class="preset-btn"></button>
                        </div>
                        <!-- Hidden Manual Sliders for precision if needed later -->
                        <div class="hidden">
                             <input id="textPosX" type="range" min="0" max="100" value="50">
                             <input id="textPosY" type="range" min="0" max="100" value="90">
                        </div>
                    </div>
                </div>

                 <!-- Section 5: Presets & Recording -->
                <div class="space-y-3 pt-4 pb-10">
                     <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider border-b border-slate-700 pb-1">Presets & Export</h2>
                     
                     <div class="flex gap-2">
                        <input type="text" id="presetName" placeholder="New Preset Name" class="flex-1 bg-slate-800 border border-slate-700 text-white text-xs rounded-md p-2">
                        <button id="savePresetBtn" class="bg-emerald-600 hover:bg-emerald-500 text-white px-3 rounded-md text-xs">Save</button>
                     </div>
                     
                     <div class="flex gap-2">
                         <select id="loadPresetSelect" class="flex-1 bg-slate-800 border border-slate-700 text-white text-xs rounded-md p-2">
                             <option value="">Load Preset...</option>
                         </select>
                         <button id="deletePresetBtn" class="bg-red-600 hover:bg-red-500 text-white px-3 rounded-md text-xs hidden">Del</button>
                     </div>

                    <div id="recording-controls" class="pt-4 border-t border-slate-700 hidden">
                        <button id="recordBtn" class="w-full bg-rose-600 hover:bg-rose-500 text-white py-2 rounded-md font-bold text-sm shadow-lg shadow-rose-900/20 flex justify-center items-center gap-2">
                            <div class="w-2 h-2 bg-white rounded-full animate-pulse"></div> Start Recording (WebM)
                        </button>
                        <p class="text-[10px] text-slate-500 text-center mt-2">Audio restarts automatically. Video downloads when song ends.</p>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="customAlert" class="fixed bottom-6 right-6 px-4 py-3 rounded-lg shadow-2xl text-sm font-medium z-50 transform transition-all duration-500 translate-y-20 opacity-0 flex items-center gap-2">
        <span id="alertIcon"></span>
        <span id="alertMsg">Notification</span>
    </div>

    <script>
    window.addEventListener('DOMContentLoaded', () => {
        
        // --- DOM Elements ---
        const elements = {
            bgInput: document.getElementById('bgInput'),
            audioInput: document.getElementById('audioInput'),
            djLogoInput: document.getElementById('djLogoInput'),
            previewBtn: document.getElementById('previewBtn'),
            recordBtn: document.getElementById('recordBtn'),
            recordingControls: document.getElementById('recording-controls'),
            spectrumType: document.getElementById('spectrumType'),
            particleType: document.getElementById('particleType'),
            spectrumColor1: document.getElementById('spectrumColor1'),
            spectrumColor2: document.getElementById('spectrumColor2'),
            barControls: document.getElementById('barControls'),
            numBars: document.getElementById('spectrumNumBars'),
            barThickness: document.getElementById('spectrumBarThickness'),
            specWidth: document.getElementById('spectrumWidth'),
            specHeight: document.getElementById('spectrumHeight'),
            specPosX: document.getElementById('spectrumPosX'),
            specPosY: document.getElementById('spectrumPosY'),
            particleControls: document.getElementById('particleControls'),
            particleOpacity: document.getElementById('particleOpacity'),
            particleShape: document.getElementById('particleShape'),
            textLine1: document.getElementById('textLine1'),
            textLine2: document.getElementById('textLine2'),
            fontFamily: document.getElementById('textFontFamily'),
            fontSize: document.getElementById('textFontSize'),
            textPosX: document.getElementById('textPosX'),
            textPosY: document.getElementById('textPosY'),
            bgPulse: document.getElementById('bgPulseEffect'),
            bloom: document.getElementById('bloomEffect'),
            bloomContainer: document.getElementById('bloomIntensityContainer'),
            bloomInt: document.getElementById('bloomIntensity'),
            posPresets: document.getElementById('text-position-presets'),
            savePreset: document.getElementById('savePresetBtn'),
            presetName: document.getElementById('presetName'),
            loadPreset: document.getElementById('loadPresetSelect'),
            delPreset: document.getElementById('deletePresetBtn'),
            canvas: document.getElementById('visualizerCanvas'),
            audio: document.getElementById('audioElement'),
            video: document.getElementById('videoElement'),
            alert: document.getElementById('customAlert'),
            overlayStatus: document.getElementById('overlayStatus')
        };

        const ctx = elements.canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on main canvas
        
        // --- App State ---
        let state = {
            audioCtx: null,
            analyser: null,
            sourceNode: null,
            videoNode: null,
            dataArray: null,
            bufferLength: 0,
            isPlaying: false,
            frameId: null,
            mediaRecorder: null,
            chunks: [],
            useVideoAudio: false,
            bgImage: null,
            djLogo: null,
            playlist: [],
            trackIndex: 0,
            rotation: 0,
            particles: [],
            ballHeights: [],
            textAlign: 'center',
            textBaseline: 'bottom',
            targetRatio: 16/9
        };

        // --- Utilities ---
        const showAlert = (msg, type = 'success') => {
            const bg = type === 'error' ? 'bg-rose-600' : 'bg-emerald-600';
            elements.alert.className = `fixed bottom-6 right-6 px-4 py-3 rounded-lg shadow-2xl text-sm font-medium z-50 text-white flex items-center gap-2 transform transition-all duration-300 ease-out translate-y-0 opacity-100 ${bg}`;
            elements.alert.querySelector('#alertMsg').textContent = msg;
            setTimeout(() => {
                elements.alert.classList.add('translate-y-20', 'opacity-0');
            }, 3000);
        };

        const resizeCanvas = () => {
            // Internal resolution
            elements.canvas.width = 1920; 
            elements.canvas.height = 1080;
            // CSS handles the display size, maintain aspect ratio via internal draw
            if(!state.isPlaying) drawStaticScene();
        };

        // --- Audio Engine ---
        const initAudio = () => {
            if (!state.audioCtx) {
                state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioCtx.createAnalyser();
                state.analyser.fftSize = 2048;
                state.bufferLength = state.analyser.frequencyBinCount;
                state.dataArray = new Uint8Array(state.bufferLength);
                
                // Create nodes
                state.sourceNode = state.audioCtx.createMediaElementSource(elements.audio);
                state.videoNode = state.audioCtx.createMediaElementSource(elements.video);
                
                // Connect analyser to speakers by default
                state.analyser.connect(state.audioCtx.destination);
            }
            if (state.audioCtx.state === 'suspended') {
                state.audioCtx.resume();
            }
        };

        const connectSource = (isVideo) => {
            try {
                if (state.sourceNode) state.sourceNode.disconnect();
                if (state.videoNode) state.videoNode.disconnect();
            } catch(e) { /* Ignore disconnect errors if not connected */ }

            if (isVideo) {
                state.videoNode.connect(state.analyser);
            } else {
                state.sourceNode.connect(state.analyser);
            }
        };

        // --- Visualizer Core ---
        const render = () => {
            if (!state.isPlaying) return;
            state.frameId = requestAnimationFrame(render);
            
            state.analyser.getByteFrequencyData(state.dataArray);
            state.rotation += 0.005;

            const w = elements.canvas.width;
            const h = elements.canvas.height;

            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Draw Background
            drawBackground(w, h);

            // Draw Visuals
            ctx.save();
            if(elements.bloom.checked) {
                ctx.shadowBlur = parseInt(elements.bloomInt.value);
                ctx.shadowColor = elements.spectrumColor1.value;
            }
            
            drawSpectrum(w, h);
            ctx.restore();

            // Draw Particles
            ctx.save();
            if(elements.bloom.checked) {
                 ctx.shadowBlur = parseInt(elements.bloomInt.value) / 2;
                 ctx.shadowColor = '#fff';
            }
            drawParticles(w, h);
            ctx.restore();

            // Draw Text
            drawText(w, h);
        };

        const drawStaticScene = () => {
            const w = elements.canvas.width;
            const h = elements.canvas.height;
            drawBackground(w, h);
            drawText(w, h);
        };

        const drawBackground = (w, h) => {
            ctx.save();
            // Pulse Effect (Increased strength as requested)
            if (elements.bgPulse.checked && state.isPlaying && state.dataArray) {
                const bass = (state.dataArray[1] + state.dataArray[2] + state.dataArray[3]) / 3;
                const scale = 1 + (bass / 255) * 0.06; // Increased from 0.02 to 0.06
                ctx.translate(w / 2, h / 2);
                ctx.scale(scale, scale);
                ctx.translate(-w / 2, -h / 2);
            }

            if (state.useVideoAudio && elements.video.readyState >= 2) {
                ctx.drawImage(elements.video, 0, 0, w, h);
            } else if (state.bgImage) {
                // Cover fit for image
                const scale = Math.max(w / state.bgImage.width, h / state.bgImage.height);
                const x = (w / 2) - (state.bgImage.width / 2) * scale;
                const y = (h / 2) - (state.bgImage.height / 2) * scale;
                ctx.drawImage(state.bgImage, x, y, state.bgImage.width * scale, state.bgImage.height * scale);
            } else {
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0,0,w,h);
            }
            
            // Darken overlay for better visibility
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0,0,w,h);
            ctx.restore();
        };

        const drawText = (w, h) => {
            const l1 = elements.textLine1.value;
            const l2 = elements.textLine2.value;
            if(!l1 && !l2) return;

            ctx.save();
            if(elements.bloom.checked) {
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.font = `${elements.fontSize.value}px "${elements.fontFamily.value}"`;
            ctx.textAlign = state.textAlign;
            ctx.textBaseline = state.textBaseline;

            const x = (elements.textPosX.value / 100) * w;
            const y = (elements.textPosY.value / 100) * h;
            const lh = parseInt(elements.fontSize.value) * 1.2;

            if(l1) ctx.fillText(l1, x, y - (l2 ? lh/2 : 0));
            if(l2) {
                ctx.font = `${parseInt(elements.fontSize.value) * 0.6}px "${elements.fontFamily.value}"`;
                ctx.fillStyle = '#cbd5e1';
                ctx.fillText(l2, x, y + (l1 ? lh/2 : 0));
            }
            ctx.restore();
        };

        // Helper to draw Center Logo
        const drawCenterLogo = (rad) => {
            if(state.djLogo) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(0, 0, rad, 0, Math.PI*2);
                ctx.clip();
                ctx.drawImage(state.djLogo, -rad, -rad, rad*2, rad*2);
                ctx.restore();
            }
        };

        // --- Visualizer Strategies ---
        const drawSpectrum = (w, h) => {
            const type = elements.spectrumType.value;
            if(type === 'none') return;

            const numBars = parseInt(elements.numBars.value);
            const thickness = parseInt(elements.barThickness.value);
            const scaleX = elements.specWidth.value / 100;
            const scaleY = elements.specHeight.value / 100;
            
            // Center calculations
            const cx = (elements.specPosX.value / 100) * w;
            const cy = (elements.specPosY.value / 100) * h;

            // Gradient
            const grad = ctx.createLinearGradient(0, h, 0, 0);
            grad.addColorStop(0, elements.spectrumColor1.value);
            grad.addColorStop(1, elements.spectrumColor2.value);
            ctx.fillStyle = grad;
            ctx.strokeStyle = grad;

            ctx.save();
            ctx.translate(cx, cy);

            switch(type) {
                case 'bars': {
                    const width = w * scaleX;
                    ctx.translate(-width/2, (h * scaleY)/2); // Align bottom
                    const gap = width / numBars;
                    for(let i=0; i<numBars; i++) {
                        const idx = Math.floor(i * (state.bufferLength/numBars));
                        const val = (state.dataArray[idx]/255) * h * scaleY;
                        ctx.fillRect(i * gap, 0, thickness, -val);
                    }
                    break;
                }
                case 'digital-eq': {
                    const width = w * scaleX;
                    const maxHeight = h * scaleY;
                    ctx.translate(-width/2, maxHeight/2);
                    const gap = width / numBars;
                    
                    for(let i=0; i<numBars; i++) {
                         const idx = Math.floor(i * (state.bufferLength/numBars));
                         const val = (state.dataArray[idx]/255) * maxHeight;
                         
                         // Draw blocks instead of continuous rect
                         const blockHeight = thickness * 1.5; // Square-ish blocks
                         const numBlocks = Math.floor(val / (blockHeight + 2)); // +2 for gap
                         
                         for(let j=0; j<numBlocks; j++) {
                             // Determine color based on height (Green -> Yellow -> Red simulation using opacity/gradient)
                             ctx.globalAlpha = 0.5 + (j/numBlocks)*0.5;
                             ctx.fillRect(i*gap, -(j*(blockHeight+2)), thickness, -blockHeight);
                         }
                         ctx.globalAlpha = 1.0;
                    }
                    break;
                }
                case 'classic-circle': {
                    const radius = Math.min(w, h) * 0.25 * scaleY;
                    const maxBarH = (Math.min(w, h) * 0.25) * scaleY;
                    
                    // Draw inner circle line base
                    ctx.beginPath();
                    ctx.arc(0, 0, radius - 4, 0, Math.PI*2);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw Logo if exists
                    drawCenterLogo(radius - 6);

                    for(let i=0; i<numBars; i++) {
                        const idx = Math.floor(i * (state.bufferLength/numBars));
                        const val = (state.dataArray[idx] / 255) * maxBarH;
                        const ang = (i / numBars) * Math.PI * 2;
                        
                        ctx.save();
                        ctx.rotate(ang);
                        ctx.fillRect(radius, -thickness/2, val + 2, thickness); 
                        ctx.restore();
                    }
                    break;
                }
                case 'eclipse': {
                    const rad = Math.min(w,h) * 0.2 * scaleY;
                    const maxExt = rad * 1.5;
                    const bass = state.dataArray[5]/255;
                    const pulseRad = rad * (1 + bass*0.1);
                    
                    // Draw spectrum behind
                    for(let i=0; i<numBars; i++) {
                        const idx = Math.floor(i*(state.bufferLength/numBars));
                        const val = (state.dataArray[idx]/255) * maxExt;
                        const ang = (i/numBars) * Math.PI * 2 + state.rotation;
                        
                        ctx.save();
                        ctx.rotate(ang);
                        ctx.fillRect(rad*0.8, -thickness/2, val + rad*0.5, thickness); // Start slightly inside
                        ctx.restore();
                    }
                    
                    // Draw Eclipse Circle
                    ctx.beginPath();
                    ctx.arc(0, 0, pulseRad, 0, Math.PI*2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                    
                    // Glow ring around eclipse
                    ctx.beginPath();
                    ctx.arc(0, 0, pulseRad, 0, Math.PI*2);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = elements.spectrumColor1.value;
                    ctx.shadowColor = elements.spectrumColor1.value;
                    ctx.shadowBlur = 20 * bass;
                    ctx.stroke();
                    ctx.shadowBlur = 0; // reset
                    
                    drawCenterLogo(pulseRad * 0.9);
                    break;
                }
                case 'spiral-wave': {
                     const maxRad = Math.min(w,h) * 0.45 * scaleY;
                     const coils = 4;
                     const points = numBars * 2; // More resolution
                     
                     ctx.beginPath();
                     ctx.lineWidth = thickness/2;
                     ctx.lineCap = 'round';
                     
                     for(let i=0; i<points; i++) {
                         const idx = Math.floor(i * (state.bufferLength/points));
                         const val = (state.dataArray[idx]/255) * 50;
                         
                         const angle = (i / points) * Math.PI * 2 * coils + state.rotation;
                         const radius = (i / points) * maxRad + val;
                         
                         const x = Math.cos(angle) * radius;
                         const y = Math.sin(angle) * radius;
                         
                         i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
                     }
                     ctx.stroke();
                    break;
                }
                case 'hexagon': {
                     const rad = Math.min(w,h) * 0.25 * scaleY;
                     const maxExt = rad * 0.6;
                     const sides = 6;
                     
                     // Pulse Center
                     const bass = state.dataArray[4]/255;
                     const centerRad = rad * (0.8 + bass * 0.2);
                     
                     ctx.beginPath();
                     for(let i=0; i<=sides; i++) {
                         const ang = i * 2 * Math.PI / sides + state.rotation;
                         const x = centerRad * Math.cos(ang);
                         const y = centerRad * Math.sin(ang);
                         i===0? ctx.moveTo(x,y) : ctx.lineTo(x,y);
                     }
                     ctx.closePath();
                     ctx.lineWidth = 5;
                     ctx.stroke();
                     
                     drawCenterLogo(centerRad * 0.9);
                     
                     // Outer Bars (Hex)
                     for(let i=0; i<numBars; i++) {
                         const idx = Math.floor(i*(state.bufferLength/numBars));
                         const val = (state.dataArray[idx]/255) * maxExt;
                         const ang = (i/numBars) * Math.PI * 2 + state.rotation;
                         
                         const startX = (rad+10) * Math.cos(ang);
                         const startY = (rad+10) * Math.sin(ang);
                         const endX = (rad+10+val) * Math.cos(ang);
                         const endY = (rad+10+val) * Math.sin(ang);
                         
                         ctx.beginPath();
                         ctx.moveTo(startX, startY);
                         ctx.lineTo(endX, endY);
                         ctx.lineWidth = thickness/2;
                         ctx.stroke();
                     }
                    break;
                }
                 case 'seismic': {
                    const width = w * scaleX;
                    const height = h * scaleY;
                    const slice = width / numBars;
                    
                    ctx.beginPath();
                    ctx.moveTo(-width/2, 0);
                    
                    // Top Wave
                    for(let i=0; i<numBars; i++) {
                        const idx = Math.floor(i * (state.bufferLength/numBars));
                        const val = (state.dataArray[idx]/255) * (height/2);
                        const x = (i * slice) - width/2;
                        ctx.lineTo(x, -val);
                    }
                    ctx.lineTo(width/2, 0);
                    
                    // Bottom Wave (Mirror)
                    for(let i=numBars-1; i>=0; i--) {
                        const idx = Math.floor(i * (state.bufferLength/numBars));
                        const val = (state.dataArray[idx]/255) * (height/2);
                        const x = (i * slice) - width/2;
                        ctx.lineTo(x, val);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                }
                case 'bouncing-bars': {
                    const width = w * scaleX;
                    ctx.translate(-width/2, (h * scaleY)/2);
                    const gap = width / numBars;
                    if(state.ballHeights.length !== numBars) state.ballHeights = new Array(numBars).fill(0);
                    
                    for(let i=0; i<numBars; i++) {
                        const idx = Math.floor(i * (state.bufferLength/numBars));
                        const val = (state.dataArray[idx]/255) * h * scaleY;
                        ctx.fillRect(i * gap, 0, thickness, -val);
                        
                        // Ball physics
                        if(val > state.ballHeights[i]) state.ballHeights[i] = val;
                        else state.ballHeights[i] = Math.max(0, state.ballHeights[i] - 2);
                        
                        ctx.beginPath();
                        ctx.arc(i*gap + thickness/2, -state.ballHeights[i] - 10, thickness/2, 0, Math.PI*2);
                        ctx.fill();
                    }
                    break;
                }
                case 'circle-bars': {
                    const rad = Math.min(w,h) * 0.25 * scaleY;
                    drawCenterLogo(rad - 10);
                    for(let i=0; i<numBars; i++) {
                        const idx = Math.floor(i*(state.bufferLength/numBars));
                        const val = (state.dataArray[idx]/255) * 100;
                        const ang = (i/numBars) * Math.PI * 2;
                        
                        ctx.save();
                        ctx.rotate(ang);
                        ctx.fillRect(rad, -thickness/2, val, thickness);
                        ctx.restore();
                    }
                    break;
                }
                case 'dj-disc': {
                    const rad = Math.min(w,h) * 0.3 * scaleY;
                    ctx.rotate(state.rotation);
                    
                    // Disc Body
                    ctx.beginPath(); ctx.arc(0,0,rad,0,Math.PI*2); ctx.fillStyle='#111'; ctx.fill();
                    ctx.strokeStyle='#333'; ctx.lineWidth=2; 
                    for(let r=rad*0.3; r<rad*0.95; r+=5) { ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); }
                    
                    // Beat Pulse Label
                    const bass = state.dataArray[10]/255;
                    const labelRad = rad*0.35 + (bass * 20);
                    
                    // Use drawCenterLogo logic manually here because of pulse effect
                    ctx.save();
                    ctx.beginPath(); ctx.arc(0,0,labelRad,0,Math.PI*2); ctx.clip();
                    if(state.djLogo) ctx.drawImage(state.djLogo, -labelRad, -labelRad, labelRad*2, labelRad*2);
                    else { ctx.fillStyle=elements.spectrumColor1.value; ctx.fill(); }
                    ctx.restore();
                    break;
                }
                case 'ring-spectrum': {
                    const rad = Math.min(w,h) * 0.25 * scaleY;
                    const maxExt = rad * 0.5;
                    
                    drawCenterLogo(rad - 10);
                    
                    ctx.beginPath(); ctx.arc(0,0, rad, 0, Math.PI*2); 
                    ctx.strokeStyle = elements.spectrumColor2.value; ctx.lineWidth=4; ctx.stroke();
                    
                    const angleStep = (Math.PI*2)/numBars;
                    ctx.lineCap = 'round';
                    ctx.lineWidth = thickness;
                    
                    for(let i=0; i<numBars; i++) {
                         const idx = Math.floor(i * (state.bufferLength/numBars));
                         const len = (state.dataArray[idx]/255) * maxExt;
                         const ang = i * angleStep;
                         ctx.beginPath();
                         ctx.arc(0,0, rad + len, ang, ang + angleStep*0.5);
                         ctx.stroke();
                    }
                    break;
                }
                case 'ncs-lines': {
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    const width = w * scaleX;
                    const maxAmp = (h * scaleY) * 0.4;
                    const subset = state.dataArray.slice(0, 100); // Focus low end
                    const slice = width / subset.length;
                    
                    ctx.beginPath();
                    for(let i=0; i<subset.length; i++) {
                        const x = (i * slice) - width/2;
                        const y = (subset[i]/255) * maxAmp;
                        i===0 ? ctx.moveTo(x, -y) : ctx.lineTo(x, -y);
                    }
                    ctx.stroke();
                    
                    // Mirror bottom
                    ctx.beginPath();
                    for(let i=0; i<subset.length; i++) {
                         const x = (i * slice) - width/2;
                         const y = (subset[i]/255) * maxAmp;
                         i===0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // Center line
                    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.beginPath(); ctx.moveTo(-width/2, 0); ctx.lineTo(width/2, 0); ctx.stroke();
                    break;
                }
                case 'wireframe-3d': {
                    const rings = 8;
                    const pts = 40;
                    const baseRad = Math.min(w,h) * 0.3 * scaleY;
                    
                    for(let r=0; r<rings; r++) {
                        const z = (r - rings/2) * 50;
                        const scale = 1 / (1 + (z * 0.002));
                        const ringRad = baseRad * scale;
                        const rot = state.rotation * (rings-r) * 0.5;
                        
                        ctx.beginPath();
                        ctx.globalAlpha = 0.3 + (0.7 * scale);
                        ctx.lineWidth = 2 * scale;
                        
                        for(let i=0; i<=pts; i++) {
                            const idx = Math.floor(i * (100/pts)); // Use first 100 bins
                            const mag = (state.dataArray[idx]/255) * 30 * scale;
                            const ang = (i/pts) * Math.PI * 2 + rot;
                            
                            const rx = Math.cos(ang) * (ringRad + mag);
                            const ry = Math.sin(ang) * (ringRad + mag);
                            i===0 ? ctx.moveTo(rx, ry) : ctx.lineTo(rx, ry);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                    break;
                }
                 case 'frequency-mirror': {
                    const width = w * scaleX;
                    const halfW = width/2;
                    const quarterBars = Math.floor(numBars/4);
                    const step = halfW / quarterBars;
                    const maxHeight = (h * scaleY) * 0.5;
                    
                    const drawQuad = (mx, my) => {
                        ctx.save();
                        ctx.scale(mx, my);
                        ctx.fillStyle = mx === 1 ? elements.spectrumColor1.value : elements.spectrumColor2.value;
                        for(let i=0; i<quarterBars; i++) {
                            const idx = Math.floor(i * (128/quarterBars));
                            const hVal = (state.dataArray[idx]/255) * maxHeight;
                            ctx.fillRect(i*step, 0, thickness, -hVal);
                        }
                        ctx.restore();
                    }
                    
                    drawQuad(1, 1);   // Bottom Right
                    drawQuad(-1, 1);  // Bottom Left
                    drawQuad(1, -1);  // Top Right
                    drawQuad(-1, -1); // Top Left
                    break;
                }
                case 'wave-mesh': {
                    const rad = Math.min(w,h) * 0.3 * scaleY;
                    const pts = 60;
                    const subset = state.dataArray.slice(0, pts);
                    
                    ctx.beginPath();
                    for(let i=0; i<pts; i++) {
                        const mag = (subset[i]/255) * 50;
                        const ang = (i/pts) * Math.PI * 2;
                        const r = rad + mag + Math.sin(state.rotation*10 + i)*10;
                        const x = Math.cos(ang) * r;
                        const y = Math.sin(ang) * r;
                        i===0? ctx.moveTo(x,y) : ctx.lineTo(x,y);
                        
                        // Dots
                        ctx.save();
                        ctx.fillStyle = elements.spectrumColor2.value;
                        ctx.beginPath(); ctx.arc(x,y, 3, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                    ctx.closePath();
                    ctx.globalAlpha=0.5; ctx.stroke(); ctx.globalAlpha=1;
                    break;
                }
                case 'dual-lines': {
                     const width = w * scaleX;
                     const maxH = (h * scaleY) * 0.4;
                     const slice = width / state.bufferLength;
                     ctx.lineWidth=2;
                     
                     ctx.beginPath();
                     for(let i=0; i<state.bufferLength; i++) {
                         const y = -(state.dataArray[i]/255)*maxH;
                         const x = (i*slice) - width/2;
                         i===0? ctx.moveTo(x,0) : ctx.lineTo(x,y);
                     }
                     ctx.stroke();
                     
                     ctx.beginPath();
                     for(let i=0; i<state.bufferLength; i++) {
                         const y = (state.dataArray[i]/255)*maxH;
                         const x = (i*slice) - width/2;
                         i===0? ctx.moveTo(x,0) : ctx.lineTo(x,y);
                     }
                     ctx.stroke();
                     break;
                }
                case 'wave': {
                     const width = w * scaleX;
                     ctx.lineWidth=3;
                     const slice = width / state.bufferLength;
                     ctx.translate(-width/2, 0);
                     
                     ctx.beginPath();
                     for(let i=0; i<state.bufferLength; i++) {
                         const v = state.dataArray[i] / 128.0;
                         const y = (v * (h*scaleY)/4) - (h*scaleY)/4;
                         const x = i * slice;
                         i===0? ctx.moveTo(x,y) : ctx.lineTo(x,y);
                     }
                     ctx.stroke();
                     break;
                }
            }
            ctx.restore();
        };

        // --- Particle System ---
        const initParticles = (w, h) => {
            state.particles = [];
            const count = 50;
            for(let i=0; i<count; i++) {
                state.particles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    size: Math.random() * 5 + 2,
                    speed: Math.random() * 3 + 1,
                    angle: Math.random() * Math.PI * 2,
                    radius: Math.random() * Math.min(w,h) * 0.4
                });
            }
        };

        const drawParticles = (w, h) => {
            const type = elements.particleType.value;
            if(type === 'none') return;

            const opacity = elements.particleOpacity.value / 100;
            const avg = state.dataArray ? state.dataArray.reduce((a,b)=>a+b,0)/state.bufferLength : 0;
            const energy = avg / 255;

            // Init if empty
            if(state.particles.length === 0) initParticles(w, h);

            state.particles.forEach((p, i) => {
                ctx.save();
                // Make particles more visible (added 0.2 base opacity)
                ctx.fillStyle = `rgba(255,255,255,${Math.min(1, opacity * (0.2 + energy * 1.5))})`;
                
                if(type === 'particle-rain') {
                    p.y += p.speed + (energy * 10);
                    if(p.y > h) { p.y = 0; p.x = Math.random() * w; }
                    drawShape(p.x, p.y, p.size);
                } 
                else if (type === 'spinning-galaxy') {
                    p.angle += 0.01 + (energy * 0.05);
                    const r = p.radius + (state.dataArray[i%100]/255)*50;
                    const x = (w/2) + Math.cos(p.angle) * r;
                    const y = (h/2) + Math.sin(p.angle) * r;
                    drawShape(x, y, p.size);
                }
                else { // Floating
                    const idx = Math.floor(i * (state.bufferLength/state.particles.length));
                    const mag = state.dataArray ? state.dataArray[idx]/255 : 0;
                    // Pulse size with audio
                    const pulsatedSize = p.size * (1 + mag);
                    drawShape(p.x, p.y, pulsatedSize);
                }
                ctx.restore();
            });
        };

        const drawShape = (x, y, s) => {
            const shape = elements.particleShape.value;
            ctx.beginPath();
            if(shape === 'circle') ctx.arc(x,y,s,0,Math.PI*2);
            else if(shape === 'square') ctx.rect(x-s, y-s, s*2, s*2);
            else { ctx.moveTo(x, y-s); ctx.lineTo(x-s, y+s); ctx.lineTo(x+s, y+s); }
            ctx.fill();
        };


        // --- Logic Integration ---
        const updateUI = () => {
            const hasMedia = (elements.bgInput.files.length || state.bgImage || elements.video.src) && 
                             (elements.audioInput.files.length || state.useVideoAudio);
            
            elements.previewBtn.disabled = !hasMedia;
            if(elements.previewBtn.disabled) elements.previewBtn.style.opacity = "0.5";
            else elements.previewBtn.style.opacity = "1";

            const isBar = ['bars','bouncing-bars','circle-bars','ring-spectrum','frequency-mirror', 'classic-circle', 'hexagon', 'seismic', 'digital-eq'].includes(elements.spectrumType.value);
            elements.barControls.style.display = isBar ? 'grid' : 'none';

            const isPart = elements.particleType.value !== 'none';
            elements.particleControls.style.display = isPart ? 'grid' : 'none';
            
            // Update Delete Button Visibility
            elements.delPreset.classList.toggle('hidden', !elements.loadPreset.value);
        };

        // Event Listeners
        elements.bgInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            
            if(file.type.startsWith('video/')) {
                state.bgImage = null;
                elements.video.src = url;
                elements.video.classList.remove('hidden');
                elements.video.onloadedmetadata = () => {
                    // Check for audio track
                    const hasAudio = elements.video.mozHasAudio || 
                                   Boolean(elements.video.webkitAudioDecodedByteCount) || 
                                   Boolean(elements.video.audioTracks && elements.video.audioTracks.length);
                    
                    state.useVideoAudio = hasAudio;
                    elements.audioInput.disabled = hasAudio;
                    if(hasAudio) showAlert("Video Audio Detected");
                    updateUI();
                }
            } else {
                elements.video.src = "";
                elements.video.classList.add('hidden');
                state.bgImage = new Image();
                state.bgImage.src = url;
                state.bgImage.onload = () => {
                    drawStaticScene();
                    state.useVideoAudio = false;
                    elements.audioInput.disabled = false;
                    updateUI();
                };
            }
        });

        elements.audioInput.addEventListener('change', e => {
            if(state.useVideoAudio) return;
            state.playlist = Array.from(e.target.files);
            if(state.playlist.length) {
                state.trackIndex = 0;
                elements.audio.src = URL.createObjectURL(state.playlist[0]);
                updateUI();
                showAlert(`Loaded: ${state.playlist[0].name}`);
            }
        });

        elements.djLogoInput.addEventListener('change', e => {
            const f = e.target.files[0];
            if(f) {
                state.djLogo = new Image();
                state.djLogo.src = URL.createObjectURL(f);
                state.djLogo.onload = () => showAlert("Logo Loaded");
            }
        });

        elements.previewBtn.addEventListener('click', () => {
            if(state.isPlaying) {
                stopPlayback();
                elements.previewBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Play`;
                elements.recordingControls.classList.add('hidden');
            } else {
                startPlayback();
                elements.previewBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> Stop`;
                elements.recordingControls.classList.remove('hidden');
            }
        });

        const startPlayback = () => {
            initAudio();
            state.isPlaying = true;
            
            if(state.useVideoAudio) {
                connectSource(true);
                elements.video.play();
            } else {
                connectSource(false);
                elements.audio.play();
                if(elements.video.src) elements.video.play(); // Play mute bg video
            }
            render();
        };

        const stopPlayback = () => {
            state.isPlaying = false;
            cancelAnimationFrame(state.frameId);
            elements.audio.pause();
            elements.video.pause();
            elements.audio.currentTime = 0;
            elements.video.currentTime = 0;
            drawStaticScene();
        };
        
        // Audio end handling
        elements.audio.onended = () => {
            if(state.mediaRecorder && state.mediaRecorder.state === 'recording') {
                 stopRecording();
            } else {
                stopPlayback();
                elements.previewBtn.click(); // Toggle button state
            }
        };

        // --- Recording Logic ---
        const startRecording = () => {
            // Reset to start for auto-recording from 0:00
            if (state.isPlaying) stopPlayback(); 
            elements.audio.currentTime = 0;
            elements.video.currentTime = 0;

            // Capture visual stream
            const canvasStream = elements.canvas.captureStream(30);
            
            // Capture audio stream
            const dest = state.audioCtx.createMediaStreamDestination();
            state.analyser.connect(dest);
            
            const tracks = [...canvasStream.getVideoTracks(), ...dest.stream.getAudioTracks()];
            const combined = new MediaStream(tracks);
            
            try {
                state.mediaRecorder = new MediaRecorder(combined, { 
                    mimeType: 'video/webm; codecs=vp9,opus',
                    videoBitsPerSecond: 5000000 // 5 Mbps
                });
            } catch(e) {
                showAlert("Browser doesn't support high-quality WebM recording", 'error');
                return;
            }
            
            state.chunks = [];
            state.mediaRecorder.ondataavailable = e => { if(e.data.size > 0) state.chunks.push(e.data); };
            state.mediaRecorder.onstop = () => {
                state.analyser.disconnect(dest); // Clean up
                const blob = new Blob(state.chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `visualizer-${Date.now()}.webm`;
                a.click();
                elements.overlayStatus.classList.add('hidden');
                showAlert("Video Exported Successfully!");
                stopPlayback();
                elements.previewBtn.click(); // Reset UI
            };
            
            state.mediaRecorder.start();
            elements.overlayStatus.classList.remove('hidden');
            elements.recordBtn.innerHTML = `<span class="animate-pulse text-red-300">Recording... Click to Stop</span>`;

            // Start playback immediately after recorder starts
            startPlayback(); 
        };
        
        const stopRecording = () => {
             if(state.mediaRecorder) state.mediaRecorder.stop();
             elements.recordBtn.innerHTML = `<div class="w-2 h-2 bg-white rounded-full animate-pulse"></div> Start Recording (WebM)`;
        };

        elements.recordBtn.addEventListener('click', () => {
            if(state.mediaRecorder?.state === 'recording') stopRecording();
            else startRecording();
        });

        // Add video end handling for auto-stop recording when video finishes
        elements.video.onended = () => {
             if(state.mediaRecorder && state.mediaRecorder.state === 'recording') {
                 stopRecording();
            }
        };

        // --- Preset Logic ---
        const loadPresets = () => {
            elements.loadPreset.innerHTML = '<option value="">Load Preset...</option>';
            for(let i=0; i<localStorage.length; i++) {
                const k = localStorage.key(i);
                if(k.startsWith('vizPreset_')) {
                    const name = k.replace('vizPreset_','');
                    const opt = document.createElement('option');
                    opt.value = name; opt.text = name;
                    elements.loadPreset.appendChild(opt);
                }
            }
        };

        elements.savePreset.addEventListener('click', () => {
            const name = elements.presetName.value.trim();
            if(!name) return showAlert("Enter a preset name", "error");
            
            const data = {};
            document.querySelectorAll('input, select').forEach(el => {
                if(el.type !== 'file' && el.id) {
                    data[el.id] = el.type === 'checkbox' ? el.checked : el.value;
                }
            });
            data.textAlign = state.textAlign;
            data.textBaseline = state.textBaseline;
            data.posActive = document.querySelector('.preset-btn.active')?.dataset.pos;
            
            localStorage.setItem(`vizPreset_${name}`, JSON.stringify(data));
            loadPresets();
            showAlert("Preset Saved");
        });

        elements.loadPreset.addEventListener('change', (e) => {
            const name = e.target.value;
            if(!name) {
                updateUI();
                return;
            }
            const data = JSON.parse(localStorage.getItem(`vizPreset_${name}`));
            if(data) {
                Object.keys(data).forEach(k => {
                    const el = document.getElementById(k);
                    if(el) {
                        if(el.type === 'checkbox') el.checked = data[k];
                        else el.value = data[k];
                        el.dispatchEvent(new Event('input')); // Trigger live updates
                        el.dispatchEvent(new Event('change'));
                    }
                });
                if(data.posActive) {
                    document.querySelectorAll('.preset-btn').forEach(b => {
                         if(b.dataset.pos === data.posActive) b.click();
                    });
                }
                showAlert("Preset Loaded");
            }
            updateUI();
        });
        
        elements.delPreset.addEventListener('click', () => {
            const name = elements.loadPreset.value;
            if(!name) return;
            localStorage.removeItem(`vizPreset_${name}`);
            loadPresets();
            elements.loadPreset.value = "";
            updateUI();
            showAlert(`Deleted preset: ${name}`, "error");
        });

        // --- UI Listeners ---
        // Bloom Toggle
        elements.bloom.addEventListener('change', (e) => {
            elements.bloomContainer.style.display = e.target.checked ? 'block' : 'none';
        });

        // Input live updates
        // Corrected the ID array here: used 'bgPulseEffect' instead of 'bgPulse'
        ['bgPulseEffect','spectrumType','particleType'].forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                el.addEventListener('change', () => {
                    updateUI();
                    if(!state.isPlaying) drawStaticScene();
                });
            }
        });
        
        document.querySelectorAll('input[type="range"], input[type="color"], input[type="text"], select').forEach(el => {
             el.addEventListener('input', () => {
                 if(!state.isPlaying) drawStaticScene();
             });
        });

        // Text Position Presets
        elements.posPresets.addEventListener('click', e => {
            if(!e.target.classList.contains('preset-btn')) return;
            
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            
            const pos = e.target.dataset.pos;
            const [v, h] = pos.split('-');
            
            state.textAlign = h; // left, center, right
            state.textBaseline = v === 'middle' ? 'middle' : (v === 'top' ? 'top' : 'bottom');

            const map = {
                'left': 5, 'center': 50, 'right': 95,
                'top': 10, 'middle': 50, 'bottom': 90
            };
            
            elements.textPosX.value = map[h];
            elements.textPosY.value = map[v];
            
            if(!state.isPlaying) drawStaticScene();
        });

        // Resize Logic
        window.addEventListener('resize', () => {
            resizeCanvas();
            drawStaticScene();
        });

        // Init
        resizeCanvas();
        loadPresets();
        updateUI();
    });
    </script>
</body>
</html>
